{"version":3,"file":"index.cjs.js","sources":["../../../node_modules/.pnpm/@carped99+ol-react@0.0.1_ol@10.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@carped99/ol-react/dist/index.es.js","../src/overlay/useTooltipOverlay.ts","../src/overlay/usePopupOverlay.ts","../src/interaction/useDrawHoleInteraction.ts","../src/interaction/useTransformInteraction.ts","../src/interaction/useTransformHandler.ts"],"sourcesContent":["import { useRef as w, useEffect as f, createContext as U, useContext as W, useState as X, useDebugValue as d, useMemo as D, useCallback as P } from \"react\";\nimport { Map as K, View as _, Geolocation as H } from \"ol\";\nimport Y from \"ol/layer/Group\";\nimport { jsx as J } from \"react/jsx-runtime\";\nimport { unByKey as E } from \"ol/Observable\";\nimport N from \"ol/View\";\nimport { DblClickDragZoom as Q, DoubleClickZoom as ee, DragAndDrop as te, DragBox as ne, DragPan as ae, DragRotateAndZoom as se, DragRotate as re, Draw as oe, Extent as le, KeyboardPan as ce, KeyboardZoom as ie, Link as ue, Modify as fe, MouseWheelZoom as me, PinchRotate as be, PinchZoom as de, Select as ye, Snap as Pe, Translate as we } from \"ol/interaction\";\nimport ge from \"ol/interaction/Pointer\";\nimport $e from \"ol/layer/Graticule\";\nimport Ie from \"ol/layer/Heatmap\";\nimport he from \"ol/layer/Image\";\nimport { OSM as ve } from \"ol/source\";\nimport { Tile as pe } from \"ol/layer\";\nimport xe from \"ol/layer/VectorImage\";\nimport Le from \"ol/layer/Vector\";\nimport Ce from \"ol/layer/VectorTile\";\nimport Se from \"ol/layer/WebGLTile\";\nimport { Style as Te, Text as De, Fill as Ee, Stroke as Oe } from \"ol/style\";\nimport { getVectorContext as Me } from \"ol/render\";\nimport { Projection as Re } from \"ol/proj\";\nconst O = (e) => {\n  const t = w(void 0);\n  return f(() => {\n    t.current = e;\n  }), t.current;\n};\nfunction Ve(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar T, B;\nfunction ke() {\n  return B || (B = 1, T = function e(t, n) {\n    if (t === n) return !0;\n    if (t && n && typeof t == \"object\" && typeof n == \"object\") {\n      if (t.constructor !== n.constructor) return !1;\n      var a, s, r;\n      if (Array.isArray(t)) {\n        if (a = t.length, a != n.length) return !1;\n        for (s = a; s-- !== 0; )\n          if (!e(t[s], n[s])) return !1;\n        return !0;\n      }\n      if (t instanceof Map && n instanceof Map) {\n        if (t.size !== n.size) return !1;\n        for (s of t.entries())\n          if (!n.has(s[0])) return !1;\n        for (s of t.entries())\n          if (!e(s[1], n.get(s[0]))) return !1;\n        return !0;\n      }\n      if (t instanceof Set && n instanceof Set) {\n        if (t.size !== n.size) return !1;\n        for (s of t.entries())\n          if (!n.has(s[0])) return !1;\n        return !0;\n      }\n      if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {\n        if (a = t.length, a != n.length) return !1;\n        for (s = a; s-- !== 0; )\n          if (t[s] !== n[s]) return !1;\n        return !0;\n      }\n      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;\n      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();\n      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();\n      if (r = Object.keys(t), a = r.length, a !== Object.keys(n).length) return !1;\n      for (s = a; s-- !== 0; )\n        if (!Object.prototype.hasOwnProperty.call(n, r[s])) return !1;\n      for (s = a; s-- !== 0; ) {\n        var i = r[s];\n        if (!e(t[i], n[i])) return !1;\n      }\n      return !0;\n    }\n    return t !== t && n !== n;\n  }), T;\n}\nvar Be = ke();\nconst M = /* @__PURE__ */ Ve(Be);\nfunction je(e, t) {\n  return e.getInteractions().getArray().find((n) => n instanceof t);\n}\nfunction g(e, t, n = Ke) {\n  return e == null || t == null || typeof e != \"object\" || typeof t != \"object\" ? e !== e && t !== t ? !0 : e === t : n(e, t);\n}\nconst Ae = (e, t, n, a = !0) => g(e, t, (s, r) => a ? Ze(s, r, n) : Ge(s, r, n)), Ke = (e, t) => e === t, Ze = (e, t, n) => {\n  for (const a of n)\n    if (!M(e[a], t[a]))\n      return !1;\n  return !0;\n}, Ge = (e, t, n) => {\n  const a = /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(t)]);\n  for (const s of a)\n    if (!n.includes(s) && !M(e[s], t[s]))\n      return !1;\n  return !0;\n};\nfunction L(e, t) {\n  return g(e, t, M);\n}\nconst qe = (e, t) => {\n  const n = O(t == null ? void 0 : t.properties);\n  f(() => {\n    L(n, t == null ? void 0 : t.properties) || e == null || e.setProperties((t == null ? void 0 : t.properties) ?? {}, !0);\n  }, [e, n, t == null ? void 0 : t.properties]);\n}, Z = U(void 0), $ = () => {\n  const e = W(Z);\n  if (!e)\n    throw new Error(\"useMapContext must be used within a MapProvider\");\n  return e;\n}, sa = ({ children: e, store: t }) => {\n  const n = ze();\n  return t = t ?? n, /* @__PURE__ */ J(Z.Provider, { value: t, children: e });\n}, ze = () => {\n  const [e, t] = X();\n  return {\n    map: e,\n    setMap: t\n  };\n}, I = (e, t) => {\n  const n = w([]);\n  f(() => {\n    if (e)\n      return () => {\n        E(n.current), n.current = [];\n      };\n  }, [e]), f(() => {\n    if (!e) return;\n    const a = Fe(t), s = _e(n.current, a);\n    Object.entries(a).filter(([r]) => !s.some((i) => i.type === r)).forEach(([r, i]) => {\n      const l = e.on(r, i);\n      s.push(l);\n    }), n.current = s;\n  }, [e, t]);\n}, Fe = (e) => Object.entries(e ?? {}).filter(([t, n]) => Ue(t, n)).reduce((t, [n, a]) => {\n  const s = Xe(n);\n  return t[s] = a, t;\n}, {}), Ue = (e, t) => typeof t == \"function\", We = (e) => e === e.toUpperCase(), Xe = (e) => {\n  if (e.length > 2 && e.startsWith(\"on\") && We(e[2])) {\n    const t = e.slice(2);\n    return t.length > 6 && t.startsWith(\"Change\") ? \"change:\" + t[6].toLowerCase() + t.slice(7) : t.toLowerCase();\n  }\n  return e;\n}, _e = (e, t) => {\n  const { validKeys: n, invalidKeys: a } = e.reduce(\n    (s, r) => {\n      const { type: i, listener: l } = r;\n      return t[i] === l ? s.validKeys.push(r) : s.invalidKeys.push(r), s;\n    },\n    { validKeys: [], invalidKeys: [] }\n  );\n  return a.length > 0 && E(a), n;\n}, He = (e = {}, t) => {\n  const { setMap: n } = $(), a = w(null), s = w(void 0), r = O(e);\n  return !s.current && a.current && (s.current = new K({\n    target: a.current,\n    ...e\n  })), f(() => {\n    a.current && (Ae(r, e, st) ? s.current && r !== e && Ne(s.current, r, e) : (Je(s.current), s.current = Ye(a.current, e), n(s.current)));\n  }, [r, e, n]), qe(s.current, e), I(s.current, t), [a, s.current];\n}, Ye = (e, t) => (console.log(\"createMap\", e, t), new K({\n  target: e,\n  ...t\n})), Je = (e) => {\n  e == null || e.setTarget(void 0), e == null || e.dispose();\n}, Ne = (e, t, n) => {\n  Qe(e, t, n), et(e, t, n), tt(e, t, n), nt(e, t, n), at(e, t, n);\n}, Qe = (e, t, n) => {\n  g(t == null ? void 0 : t.view, n == null ? void 0 : n.view) || e.setView((n == null ? void 0 : n.view) ?? new _());\n}, et = (e, t, n) => {\n  g(t == null ? void 0 : t.layers, n == null ? void 0 : n.layers) || (n == null ? void 0 : n.layers) != null && (n.layers instanceof Y ? e.setLayerGroup(n.layers) : e.setLayers(n.layers));\n}, tt = (e, t, n) => {\n  g(t == null ? void 0 : t.controls, n == null ? void 0 : n.controls) || (n == null ? void 0 : n.controls) != null && n.controls.forEach(e.addControl);\n}, nt = (e, t, n) => {\n  g(t == null ? void 0 : t.interactions, n == null ? void 0 : n.interactions) || (n == null ? void 0 : n.interactions) != null && n.interactions.forEach(e.addInteraction);\n}, at = (e, t, n) => {\n  g(t == null ? void 0 : t.overlays, n == null ? void 0 : n.overlays) || (n == null ? void 0 : n.overlays) != null && n.overlays.forEach(e.addOverlay);\n}, st = [\"keyboardEventTarget\", \"maxTilesLoading\", \"moveTolerance\", \"pixelRatio\"], ra = (e) => {\n  const t = rt(e.view);\n  return He({ ...e, view: t });\n};\nvar j, A;\nconst C = typeof process < \"u\" && ((j = process == null ? void 0 : process.env) != null && j.REACT_OL_DEBUG) || typeof window < \"u\" && !((A = window == null ? void 0 : window.location) != null && A.search.includes(\"react-ol-debug=true\")) ? (e, ...t) => console.debug(e(), ...t) : (e, ...t) => console.debug(e(), ...t), o = (e, t) => {\n  d(t);\n  const n = w(void 0), a = w(!1), s = O(t);\n  return n.current === void 0 && (C(() => \"Create instance\", t), n.current = e.createInstance(t, s), a.current = !0), f(() => () => {\n    a.current = !1, n.current = void 0;\n  }, []), f(() => {\n    if (a.current) {\n      if (!n.current) throw new Error(\"This should not be reached\");\n      e.shouldCreateInstance(t, s) ? n.current = e.createInstance(t, s) : e.shouldUpdateInstance(t, s) && e.updateInstance(n.current, t, s);\n    } else\n      n.current = e.createInstance(t, s), a.current = !0;\n  }, [t, s, e]), n.current;\n}, h = (e, t) => D(() => c(e, t), [e, t]), c = (e, t) => ({\n  createInstance: e,\n  shouldCreateInstance: (r, i) => r === i ? !1 : t.some((l) => {\n    const m = r == null ? void 0 : r[l.name], y = i == null ? void 0 : i[l.name];\n    if (!l.settable) {\n      const b = !L(m, y);\n      return b && C(() => `Recreate instance trigger by ${l.name}`), b;\n    }\n    if (l.settable && !l.nullable) {\n      const b = y != null && m == null;\n      return b && C(() => `Recreate instance trigger by ${l.name}`), b;\n    }\n    return !1;\n  }),\n  updateInstance: (r, i, l) => t.filter((m) => m.settable).forEach((m) => {\n    const y = i == null ? void 0 : i[m.name], b = l == null ? void 0 : l[m.name];\n    if (L(y, b))\n      return;\n    const x = `set${m.name[0].toUpperCase() + m.name.slice(1)}`;\n    r[x](y);\n  }),\n  shouldUpdateInstance: (r, i) => r === i ? !1 : t.filter((l) => l.settable).some((l) => {\n    const m = r == null ? void 0 : r[l.name], y = i == null ? void 0 : i[l.name], b = !L(m, y);\n    return b && C(() => `Update instance trigger by ${l.name}`), b;\n  })\n}), rt = (e, t) => {\n  const n = o(ct, e);\n  return I(n, t), n;\n}, ot = (e) => new N(e), lt = [\n  { name: \"constrainRotation\", settable: !1 },\n  { name: \"enableRotation\", settable: !1 },\n  { name: \"constrainOnlyCenter\", settable: !1 },\n  { name: \"smoothExtentConstraint\", settable: !1 },\n  { name: \"smoothResolutionConstraint\", settable: !1 },\n  { name: \"minResolution\", settable: !1 },\n  { name: \"maxResolution\", settable: !1 },\n  { name: \"multiWorld\", settable: !1 },\n  { name: \"showFullExtent\", settable: !1 },\n  { name: \"projection\", settable: !1 },\n  { name: \"resolutions\", settable: !1 },\n  { name: \"zoomFactor\", settable: !1 },\n  { name: \"padding\", settable: !1 },\n  { name: \"extent\", settable: !1 },\n  { name: \"center\", settable: !0, nullable: !0 },\n  { name: \"constrainResolution\", settable: !0 },\n  { name: \"maxZoom\", settable: !0 },\n  { name: \"minZoom\", settable: !0 },\n  { name: \"rotation\", settable: !0 },\n  { name: \"resolution\", settable: !0, nullable: !0 },\n  { name: \"zoom\", settable: !0 }\n], ct = c(ot, lt), oa = (e = {}, t) => {\n  const n = o(ft, e);\n  return I(n, t), n;\n}, it = (e) => new H(e), ut = [\n  { name: \"tracking\", settable: !0 },\n  { name: \"trackingOptions\", settable: !0 },\n  { name: \"projection\", settable: !0 }\n], ft = c(it, ut), u = (e, t, n = !0) => {\n  const { map: a } = $();\n  I(e, t), f(() => {\n    if (!(!a || !e))\n      return a.addInteraction(e), () => {\n        a.removeInteraction(e);\n      };\n  }, [a, e]), f(() => {\n    e == null || e.setActive(n);\n  }, [e, n]);\n}, la = (e = {}, t, n = !0) => {\n  const a = o(dt, e);\n  return u(a, t, n), a;\n}, mt = (e) => new Q(e), bt = [\n  { name: \"condition\", settable: !1 },\n  { name: \"duration\", settable: !1 },\n  { name: \"delta\", settable: !1 }\n], dt = c(mt, bt), ca = (e = {}, t, n = !0) => {\n  const a = o(wt, e);\n  return u(a, t, n), a;\n}, yt = (e) => new ee(e), Pt = [{ name: \"duration\" }, { name: \"delta\" }], wt = c(yt, Pt), ia = (e = {}, t, n = !0) => {\n  const a = o(It, e);\n  return u(a, t, n), a;\n}, gt = (e) => new te(e), $t = [\n  { name: \"formatConstructors\", settable: !1 },\n  { name: \"source\", settable: !1 },\n  { name: \"projection\", settable: !1 },\n  { name: \"target\", settable: !1 }\n], It = c(gt, $t), ua = (e = {}, t, n = !0) => {\n  const a = o(pt, e);\n  return u(a, t, n), a;\n}, ht = (e) => new ne(e), vt = [\n  { name: \"className\", settable: !1 },\n  { name: \"condition\", settable: !1 },\n  { name: \"minArea\", settable: !1 },\n  { name: \"boxEndCondition\", settable: !1 }\n  // { name: 'onBoxEnd', settable: true },\n], pt = c(ht, vt), fa = (e = {}, t, n = !0) => {\n  const a = o(Ct, e);\n  return u(a, t, n), a;\n}, xt = (e) => new ae(e), Lt = [\n  { name: \"condition\", settable: !1 },\n  { name: \"onFocusOnly\", settable: !1 },\n  { name: \"kinetic\", settable: !1 }\n], Ct = c(xt, Lt), ma = (e = {}, t, n = !0) => {\n  const a = o(Dt, e);\n  return u(a, t, n), a;\n}, St = (e) => new se(e), Tt = [\n  { name: \"condition\", settable: !1 },\n  { name: \"duration\", settable: !1 }\n], Dt = c(St, Tt), ba = (e = {}, t, n = !0) => {\n  const a = o(Mt, e);\n  return u(a, t, n), a;\n}, Et = (e) => new re(e), Ot = [\n  { name: \"condition\", settable: !1 },\n  { name: \"duration\", settable: !1 }\n], Mt = c(Et, Ot), da = (e, t, n = !0) => {\n  const a = o(kt, e);\n  return u(a, t, n), a;\n}, Rt = (e) => new oe(e), Vt = [\n  { name: \"type\", settable: !1 },\n  { name: \"clickTolerance\", settable: !1 },\n  { name: \"features\", settable: !1 },\n  { name: \"source\", settable: !1 },\n  { name: \"dragVertexDelay\", settable: !1 },\n  { name: \"snapTolerance\", settable: !1 },\n  { name: \"stopClick\", settable: !1 },\n  { name: \"maxPoints\", settable: !1 },\n  { name: \"minPoints\", settable: !1 },\n  { name: \"finishCondition\", settable: !1 },\n  { name: \"style\", settable: !1 },\n  { name: \"geometryFunction\", settable: !1 },\n  { name: \"geometryName\", settable: !1 },\n  { name: \"geometryLayout\", settable: !1 },\n  { name: \"condition\", settable: !1 },\n  { name: \"freehand\", settable: !1 },\n  { name: \"freehandCondition\", settable: !1 },\n  { name: \"trace\", settable: !1 },\n  { name: \"traceSource\", settable: !1 },\n  { name: \"wrapX\", settable: !1 }\n], kt = c(Rt, Vt), ya = (e = {}, t, n = !0) => {\n  const a = o(At, e);\n  return u(a, t, n), a;\n}, Bt = (e) => new le(e), jt = [\n  { name: \"condition\", settable: !1 },\n  { name: \"extent\", settable: !1 },\n  { name: \"boxStyle\", settable: !1 },\n  { name: \"pixelTolerance\", settable: !1 },\n  { name: \"pointerStyle\", settable: !1 },\n  { name: \"wrapX\", settable: !1 }\n], At = c(Bt, jt), Pa = (e = {}, t, n = !0) => {\n  const a = o(Gt, e);\n  return u(a, t, n), a;\n}, Kt = (e) => new ce(e), Zt = [\n  { name: \"condition\", settable: !1 },\n  { name: \"duration\", settable: !1 },\n  { name: \"pixelDelta\", settable: !1 }\n], Gt = c(Kt, Zt), wa = (e = {}, t, n = !0) => {\n  const a = o(Ft, e);\n  return u(a, t, n), a;\n}, qt = (e) => new ie(e), zt = [\n  { name: \"condition\", settable: !1 },\n  { name: \"condition\", settable: !1 },\n  { name: \"condition\", settable: !1 }\n], Ft = c(qt, zt), ga = (e = {}, t, n = !0) => {\n  const a = o(Xt, e);\n  return u(a, t, n), a;\n}, Ut = (e) => new ue(e), Wt = [\n  { name: \"animate\", settable: !1 },\n  { name: \"params\", settable: !1 },\n  { name: \"replace\", settable: !1 },\n  { name: \"prefix\", settable: !1 }\n], Xt = c(Ut, Wt), $a = (e, t, n = !0) => {\n  const a = o(Yt, e);\n  return u(a, t, n), a;\n}, _t = (e) => new fe(e), Ht = [\n  { name: \"condition\", settable: !0 },\n  { name: \"deleteCondition\", settable: !0 },\n  { name: \"insertVertexCondition\", settable: !0 },\n  { name: \"pixelTolerance\", settable: !0 },\n  { name: \"style\", settable: !0 },\n  { name: \"source\", settable: !1 },\n  { name: \"hitDetection\", settable: !1 },\n  { name: \"features\", settable: !1 },\n  { name: \"wrapX\", settable: !1 },\n  { name: \"snapToPointer\", settable: !1 }\n], Yt = c(_t, Ht), Ia = (e = {}, t, n = !0) => {\n  const a = o(Qt, e);\n  return u(a, t, n), a;\n}, Jt = (e) => new me(e), Nt = [\n  { name: \"condition\", settable: !1 },\n  { name: \"onFocusOnly\", settable: !1 },\n  { name: \"maxDelta\", settable: !1 },\n  { name: \"duration\", settable: !1 },\n  { name: \"timeout\", settable: !1 },\n  { name: \"useAnchor\", settable: !0 },\n  { name: \"constrainResolution\", settable: !1 }\n], Qt = c(Jt, Nt), ha = (e = {}, t, n = !0) => {\n  const a = o(nn, e);\n  return u(a, t, n), a;\n}, en = (e) => new be(e), tn = [\n  { name: \"duration\", settable: !1 },\n  { name: \"threshold\", settable: !1 }\n], nn = c(en, tn), va = (e = {}, t, n = !0) => {\n  const a = o(rn, e);\n  return u(a, t, n), a;\n}, an = (e) => new de(e), sn = [{ name: \"duration\", settable: !1 }], rn = c(an, sn), pa = (e = {}, t = !0) => {\n  const n = D(() => new ge(e), [e]);\n  return u(n, void 0, t), n;\n}, xa = (e = {}, t, n = !0) => {\n  const a = o(cn, e);\n  return u(a, t, n), a;\n}, on = (e) => new ye(e), ln = [\n  { name: \"addCondition\", settable: !1 },\n  { name: \"condition\", settable: !1 },\n  { name: \"layers\", settable: !1 },\n  { name: \"style\", settable: !1 },\n  { name: \"removeCondition\", settable: !1 },\n  { name: \"toggleCondition\", settable: !1 },\n  { name: \"multi\", settable: !1 },\n  { name: \"features\", settable: !1 },\n  { name: \"filter\", settable: !1 },\n  { name: \"hitTolerance\", settable: !0 }\n], cn = c(on, ln), La = (e = {}, t, n = !0) => {\n  if (!e.features && !e.source)\n    throw new Error(\"snapOptions should have features or source\");\n  const a = o(mn, e);\n  return u(a, t, n), a;\n}, un = (e) => new Pe(e), fn = [\n  { name: \"features\", settable: !1 },\n  { name: \"edge\", settable: !1 },\n  { name: \"vertex\", settable: !1 },\n  { name: \"pixelTolerance\", settable: !1 },\n  { name: \"source\", settable: !1 }\n], mn = c(un, fn), Ca = (e, t) => {\n  const { map: n } = $();\n  f(() => {\n    if (!n) return;\n    const a = je(n, e);\n    return a == null || a.setActive(t), () => {\n      a == null || a.setActive(!t);\n    };\n  }, [n, t, e]);\n}, Sa = (e = {}, t, n = !0) => {\n  const a = o(yn, e);\n  return u(a, t, n), a;\n}, bn = (e) => new we(e), dn = [\n  { name: \"condition\", settable: !1 },\n  { name: \"features\", settable: !1 },\n  { name: \"layers\", settable: !1 },\n  { name: \"filter\", settable: !1 },\n  { name: \"hitTolerance\", settable: !1 }\n], yn = c(bn, dn), R = (e, t) => {\n  const { map: n } = $();\n  return f(() => {\n    if (!(!n || !e))\n      return t.map != null ? () => {\n        e.setMap(null);\n      } : (n.addLayer(e), () => {\n        n.removeLayer(e);\n      });\n  }, [n, e, t.map]), f(() => {\n    e.getSource() != t.source && (console.log(\"===> update source\", e, t.source), e.setSource(t.source ?? null));\n  }, [e, t.source]), e;\n}, v = (e, t) => {\n  R(e, t);\n}, Pn = [\n  { name: \"className\" },\n  // A CSS class name to set to the layer element.\n  { name: \"opacity\", settable: !0 },\n  // Opacity (0, 1).\n  { name: \"visible\", settable: !0 },\n  // Visibility.\n  { name: \"extent\", settable: !0, nullable: !0 },\n  // The bounding extent for layer rendering. The layer will not be rendered outside of this extent.\n  { name: \"zIndex\", settable: !0, nullable: !0 },\n  // The z-index for layer rendering. At rendering time, the layers will be ordered, first by Z-index and then by position.\n  { name: \"minZoom\", settable: !0 },\n  // The minimum view zoom level (exclusive) above which this layer will be visible.\n  { name: \"maxZoom\", settable: !0 },\n  // The maximum view zoom level (inclusive) at which this layer will be visible.\n  { name: \"minResolution\", settable: !0 },\n  // The minimum resolution (inclusive) at which this layer will be visible.\n  { name: \"maxResolution\", settable: !0 },\n  // The maximum resolution (exclusive) below which this layer will be visible.\n  { name: \"background\", settable: !1, nullable: !0 }\n  // Background color for the layer. If not specified, no background will be rendered.\n  // { name: 'properties', settable: true, nullable: true },\n], V = [\n  ...Pn,\n  { name: \"source\", settable: !0, nullable: !0 },\n  // Source.\n  { name: \"map\", settable: !0, nullable: !0 }\n  // Source.\n], G = [\n  ...V,\n  { name: \"cacheSize\" },\n  { name: \"preload\", settable: !0 }\n], p = [\n  ...V,\n  { name: \"renderOrder\" },\n  { name: \"renderBuffer\" },\n  { name: \"updateWhileAnimating\" },\n  { name: \"updateWhileInteracting\" },\n  { name: \"declutter\", settable: !0, nullable: !1 },\n  { name: \"style\", settable: !0, nullable: !0 }\n], wn = [...V], Ta = (e) => {\n  d(e);\n  const t = o(In, e);\n  return v(t, e), t;\n}, gn = [\n  ...p,\n  { name: \"strokeStyle\", settable: !1 },\n  { name: \"targetSize\", settable: !1 },\n  { name: \"showLabels\", settable: !1 },\n  { name: \"maxLines\", settable: !1 },\n  { name: \"lonLabelFormatter\", settable: !1 },\n  { name: \"latLabelFormatter\", settable: !1 },\n  { name: \"lonLabelPosition\", settable: !1 },\n  { name: \"latLabelPosition\", settable: !1 },\n  { name: \"lonLabelStyle\", settable: !1 },\n  { name: \"latLabelStyle\", settable: !1 },\n  { name: \"intervals\", settable: !1 },\n  { name: \"wrapX\", settable: !1 }\n], $n = (e) => new $e(e), In = c($n, gn), Da = (e) => {\n  d(e);\n  const t = h(\n    P((a) => new Ie(a), []),\n    hn\n  ), n = o(t, e);\n  return v(n, e), n;\n}, hn = [\n  ...p,\n  { name: \"gradient\", settable: !0 },\n  { name: \"radius\", settable: !0 },\n  { name: \"blur\", settable: !0 },\n  { name: \"weight\", settable: !0 }\n], vn = (e, t) => {\n  R(e, t);\n}, Ea = (e) => {\n  d(e);\n  const t = h(\n    P((a) => new he(a), []),\n    pn\n  ), n = o(t, e);\n  return vn(n, e), n;\n}, pn = [...wn], q = (e, t) => {\n  R(e, t), f(() => {\n    t.preload != null && e.getPreload() !== t.preload && e.setPreload(t.preload);\n  }, [e, t.preload]);\n}, xn = (e, t) => {\n  d(e);\n  const n = h(\n    P((s) => new pe(s), []),\n    Ln\n  ), a = o(n, e);\n  return I(a, t), q(a, e), a;\n}, Ln = [...G], Oa = (e) => {\n  d(e);\n  const t = D(() => new ve(e == null ? void 0 : e.source), [e == null ? void 0 : e.source]);\n  return xn({\n    ...e,\n    source: t\n  });\n}, Ma = (e) => {\n  d(e);\n  const t = h(\n    P((a) => new xe(a), []),\n    Cn\n  ), n = o(t, e);\n  return v(n, e), n;\n}, Cn = [...p, { name: \"imageRatio\", settable: !1 }], Sn = (e) => {\n  d(e);\n  const t = h(\n    P((a) => new Le(a), []),\n    Tn\n  ), n = o(t, e);\n  return v(n, e), n;\n}, Tn = [...p], Ra = (e) => {\n  d(e);\n  const t = h(\n    P((a) => new Ce(a), []),\n    Dn\n  ), n = o(t, e);\n  return v(n, e), n;\n}, Dn = [\n  ...p,\n  { name: \"preload\", settable: !1 },\n  { name: \"cacheSize\", settable: !1 },\n  { name: \"renderMode\", settable: !1 }\n], Va = (e) => {\n  d(e);\n  const t = o(Mn, e);\n  return q(t, e), t;\n}, En = (e) => new Se(e), On = [\n  ...G,\n  { name: \"style\", settable: !0, nullable: !0 }\n], Mn = c(En, On), ka = (e, t) => {\n  const { map: n } = $();\n  I(e, t), f(() => {\n    if (!(!n || !e))\n      return n.addOverlay(e), () => {\n        n.removeOverlay(e);\n      };\n  }, [n, e]);\n}, Ba = () => {\n  const { map: e } = $(), t = w(void 0), n = Sn({}), a = P(() => {\n    t.current && (E(t.current), t.current = void 0);\n  }, []);\n  return P(\n    (s, r) => {\n      a();\n      const i = (/* @__PURE__ */ new Date()).getTime(), l = 1500, m = s.getGeometry().clone();\n      t.current = n.on(\"postrender\", y);\n      function y(b) {\n        const x = Me(b), S = b.frameState.time - i;\n        let k = 1;\n        if (S > 1e3) {\n          const F = l - S;\n          k = Math.max(F / (l - 1e3), 0);\n        }\n        if (S > l) {\n          a();\n          return;\n        }\n        const z = Rn(r, k);\n        x.setStyle(z), x.drawGeometry(m), requestAnimationFrame(() => e == null ? void 0 : e.render());\n      }\n      e == null || e.render();\n    },\n    [e, a, n]\n  );\n}, Rn = (e, t) => new Te({\n  text: new De({\n    text: e,\n    font: \"bold 14px sans-serif\",\n    fill: new Ee({\n      color: \"rgba(255, 255, 255, \" + t + \")\"\n      // 텍스트 색상 (흰색)\n    }),\n    stroke: new Oe({\n      color: \"rgba(0, 0, 0, \" + t + \")\",\n      // 외곽선 색상 (검은색)\n      width: 3\n      // 외곽선 두께\n    }),\n    padding: [5, 5, 5, 5],\n    // 텍스트 주변 여백\n    // backgroundFill: new Fill({\n    //   color: 'rgba(0, 0, 0, 0.6)', // 반투명 검정 배경\n    // }),\n    offsetX: 0,\n    // 텍스트 X 축 위치 조정\n    offsetY: 0,\n    // 텍스트 Y 축 위치 조정\n    textAlign: \"center\"\n    // 텍스트 정렬\n  })\n}), ja = (e) => o(Bn, e), Vn = (e) => new Re(e), kn = [\n  { name: \"code\", settable: !1 },\n  { name: \"units\", settable: !1 },\n  { name: \"axisOrientation\", settable: !1 },\n  { name: \"metersPerUnit\", settable: !1 },\n  { name: \"extent\", settable: !0 },\n  { name: \"worldExtent\", settable: !0 },\n  { name: \"global\", settable: !0 },\n  { name: \"getPointResolution\", settable: !0 }\n], Bn = c(Vn, kn);\nexport {\n  Z as MapContext,\n  sa as MapProvider,\n  la as useDblClickDragZoomInteraction,\n  ca as useDblClickZoomInteraction,\n  ia as useDragAndDropInteraction,\n  ua as useDragBoxInteraction,\n  fa as useDragPanInteraction,\n  ma as useDragRotateAndZoomInteraction,\n  ba as useDragRotateInteraction,\n  da as useDrawInteraction,\n  I as useEvents,\n  ya as useExtentInteraction,\n  oa as useGeolocation,\n  Ta as useGraticuleLayer,\n  Da as useHeatmapLayer,\n  Ea as useImageLayer,\n  u as useInteraction,\n  Pa as useKeyboardPanInteraction,\n  wa as useKeyboardZoomInteraction,\n  ga as useLinkInteraction,\n  He as useMap,\n  $ as useMapContext,\n  ra as useMapView,\n  $a as useModifyInteraction,\n  Ia as useMouseWheelZoomInteraction,\n  Oa as useOSMLayer,\n  ka as useOverlay,\n  ha as usePinchRotateInteraction,\n  va as usePinchZoomInteraction,\n  pa as usePointerInteraction,\n  ja as useProjection,\n  xa as useSelectInteraction,\n  Ba as useShowText,\n  La as useSnapInteraction,\n  xn as useTileLayer,\n  Ca as useToggleInteraction,\n  Sa as useTranslateInteraction,\n  Ma as useVectorImageLayer,\n  Sn as useVectorLayer,\n  Ra as useVectorTileLayer,\n  rt as useView,\n  Va as useWebGLTileLayer\n};\n//# sourceMappingURL=index.es.js.map\n","import Tooltip, { Options } from 'ol-ext/overlay/Tooltip';\r\nimport { useMemo } from 'react';\r\nimport { useOverlay } from '@carped99/ol-react';\r\n\r\n/**\r\n * Options for the overlay.\r\n *\r\n * @category Overlay Option\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\r\nexport interface TooltipOverlayOptions extends Options {}\r\n\r\n/**\r\n * 지도에 `Tooltip`을 추가하는 훅\r\n * @param options - Options for the overlay.\r\n *\r\n * @category Overlay\r\n */\r\nexport const useTooltipOverlay = (options?: TooltipOverlayOptions) => {\r\n  const tooltip = useMemo(() => {\r\n    return new Tooltip(options);\r\n  }, [options]);\r\n\r\n  useOverlay(tooltip);\r\n\r\n  return tooltip;\r\n};\r\n","import Popup, { Options } from 'ol-ext/overlay/Popup';\r\nimport { useMemo } from 'react';\r\nimport { useOverlay } from '@carped99/ol-react';\r\n\r\n/**\r\n * Options for the overlay.\r\n *\r\n * @category Overlay Option\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\r\nexport interface PopupOverlayOptions extends Options {}\r\n\r\n/**\r\n * 지도에 `Popup`을 추가하는 훅\r\n * @param options - Options for the overlay.\r\n *\r\n * @category Overlay\r\n */\r\nexport const usePopupOverlay = (options: PopupOverlayOptions) => {\r\n  const popup = useMemo(() => {\r\n    return new Popup(options);\r\n  }, [options]);\r\n\r\n  useOverlay(popup);\r\n\r\n  return popup;\r\n};\r\n","import { useEffect, useMemo } from 'react';\r\nimport DrawHole, { Options } from 'ol-ext/interaction/DrawHole';\r\nimport { useInteraction } from '@carped99/ol-react';\r\n\r\n/**\r\n * Options for the - {@link useDrawHoleInteraction} hook.\r\n *\r\n * @category Interaction/Option\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\r\nexport interface DrawHoleInteractionOptions extends Options {}\r\n\r\n/**\r\n * Draw holes in a polygon.\r\n *\r\n * @param options - Options for the interaction.\r\n * @param active - Whether the interaction should be active.\r\n *\r\n * @see - {@link https://viglino.github.io/ol-ext/doc/doc-pages/interaction/DrawHole.html | DrawHole}\r\n * @category Interaction\r\n */\r\nexport const useDrawHoleInteraction = (options: DrawHoleInteractionOptions, active = true) => {\r\n  const interaction = useMemo(() => new DrawHole(options), [options]);\r\n\r\n  useInteraction(interaction, undefined, active);\r\n\r\n  useEffect(() => {\r\n    if (options.trace) {\r\n      interaction.setTrace(options.trace);\r\n    }\r\n  }, [interaction, options.trace]);\r\n\r\n  return interaction;\r\n};\r\n","import { useMemo } from 'react';\r\nimport Transform, { Options } from 'ol-ext/interaction/Transform';\r\nimport { useInteraction } from '@carped99/ol-react';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\r\nexport interface TransformInteractionOptions extends Options {}\r\n\r\nexport const useTransformInteraction = (options: TransformInteractionOptions = {}, active = true) => {\r\n  const transform = useMemo(() => new Transform(options), [options]);\r\n\r\n  useInteraction(transform, undefined, active);\r\n\r\n  return transform;\r\n};\r\n","import { Options as TransformOptions } from 'ol-ext/interaction/Transform';\r\nimport { useEffect, useMemo } from 'react';\r\nimport { unByKey } from 'ol/Observable';\r\nimport type { Layer } from 'ol/layer';\r\nimport { useTransformInteraction } from './useTransformInteraction';\r\n\r\nexport const RotateAnglePropertyName = 'rotate:angle';\r\n\r\n// 회전, 이동할 수 있도록 하는 인터렉션을 생성한다.\r\nexport const useTransformHandler = ({ active, layers }: { active: boolean; layers: Layer[] }) => {\r\n  const options = useMemo<TransformOptions>(\r\n    () => ({\r\n      layers,\r\n      translate: true,\r\n      stretch: false,\r\n      scale: false,\r\n      rotate: true,\r\n    }),\r\n    [layers],\r\n  );\r\n\r\n  const transform = useTransformInteraction(options, active);\r\n\r\n  /**\r\n   * 회전 중에 발생하는 이벤트를 처리한다.\r\n   * 회전각도는 'rotate:angle' 속성에 저장한다.\r\n   * 회전 중에는 '__rotating:angle__' 속성에 임시로 저장한다.\r\n   */\r\n  useEffect(() => {\r\n    const tempPropertyName = '__rotating:angle__';\r\n\r\n    const rotateStartKey = transform.on('rotatestart', (event) => {\r\n      event.features.forEach((feature) => {\r\n        // 현재 각도를 임시로 저장한다.\r\n        const initial: number = feature.get(RotateAnglePropertyName) || 0;\r\n        feature.set(tempPropertyName, initial, true);\r\n      });\r\n    });\r\n\r\n    const rotateEndKey = transform.on('rotateend', (event) => {\r\n      event.features.forEach((feature) => {\r\n        // 임시로 저장한 각도를 삭제한다.\r\n        feature.unset(tempPropertyName, true);\r\n      });\r\n    });\r\n\r\n    const rotatingKey = transform.on('rotating', (event) => {\r\n      event.features.forEach((feature) => {\r\n        // 이벤트로부터 회전값을 가져와 현재 각도에서 빼서 회전값을 설정한다.\r\n        const initial: number = feature.get(tempPropertyName);\r\n        feature.set(RotateAnglePropertyName, initial - event.angle, true);\r\n      });\r\n    });\r\n\r\n    return () => {\r\n      unByKey(rotateStartKey);\r\n      unByKey(rotateEndKey);\r\n      unByKey(rotatingKey);\r\n    };\r\n  }, [transform]);\r\n};\r\n"],"names":["Z","U","$","W","I","t","n","w","f","E","a","Fe","s","_e","r","i","Ue","Xe","We","j","A","u","ka","useTooltipOverlay","options","tooltip","useMemo","Tooltip","useOverlay","usePopupOverlay","popup","Popup","useDrawHoleInteraction","active","interaction","DrawHole","useInteraction","useEffect","useTransformInteraction","transform","Transform","RotateAnglePropertyName","useTransformHandler","layers","tempPropertyName","rotateStartKey","event","feature","initial","rotateEndKey","rotatingKey","unByKey"],"mappings":"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","x_google_ignoreList":[0]}