"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const E=require("ol-ext/overlay/Tooltip"),u=require("react");require("ol");require("ol/layer/Group");require("react/jsx-runtime");const f=require("ol/Observable");require("ol/View");require("ol/interaction");require("ol/interaction/Pointer");require("ol/layer/Graticule");require("ol/layer/Heatmap");require("ol/layer/Image");require("ol/source");require("ol/layer");require("ol/layer/VectorImage");require("ol/layer/Vector");require("ol/layer/VectorTile");require("ol/layer/WebGLTile");require("ol/style");require("ol/render");require("ol/proj");const K=require("ol-ext/overlay/Popup"),O=require("ol-ext/interaction/DrawHole"),T=require("ol-ext/interaction/Transform"),b=u.createContext(void 0),m=()=>{const e=u.useContext(b);if(!e)throw new Error("useMapContext must be used within a MapProvider");return e},g=(e,r)=>{const t=u.useRef([]);u.useEffect(()=>{if(e)return()=>{f.unByKey(t.current),t.current=[]}},[e]),u.useEffect(()=>{if(!e)return;const n=C(),o=_(t.current,n);Object.entries(n).filter(([s])=>!o.some(a=>a.type===s)).forEach(([s,a])=>{const l=e.on(s,a);o.push(l)}),t.current=o},[e,r])},C=e=>Object.entries({}).filter(([r,t])=>M(r,t)).reduce((r,[t,n])=>{const o=I(t);return r[o]=n,r},{}),M=(e,r)=>typeof r=="function",P=e=>e===e.toUpperCase(),I=e=>{if(e.length>2&&e.startsWith("on")&&P(e[2])){const r=e.slice(2);return r.length>6&&r.startsWith("Change")?"change:"+r[6].toLowerCase()+r.slice(7):r.toLowerCase()}return e},_=(e,r)=>{const{validKeys:t,invalidKeys:n}=e.reduce((o,s)=>{const{type:a,listener:l}=s;return r[a]===l?o.validKeys.push(s):o.invalidKeys.push(s),o},{validKeys:[],invalidKeys:[]});return n.length>0&&f.unByKey(n),t};var p,q;typeof process<"u"&&(p=process==null?void 0:process.env)!=null&&p.REACT_OL_DEBUG||typeof window<"u"&&((q=window==null?void 0:window.location)!=null&&q.search.includes("react-ol-debug=true"));const v=(e,r,t=!0)=>{const{map:n}=m();g(e,r),u.useEffect(()=>{if(!(!n||!e))return n.addInteraction(e),()=>{n.removeInteraction(e)}},[n,e]),u.useEffect(()=>{e==null||e.setActive(t)},[e,t])},h=(e,r)=>{const{map:t}=m();g(e,r),u.useEffect(()=>{if(!(!t||!e))return t.addOverlay(e),()=>{t.removeOverlay(e)}},[t,e])},B=e=>{const r=u.useMemo(()=>new E(e),[e]);return h(r),r},A=e=>{const r=u.useMemo(()=>new K(e),[e]);return h(r),r},H=(e,r=!0)=>{const t=u.useMemo(()=>new O(e),[e]);return v(t,void 0,r),u.useEffect(()=>{e.trace&&t.setTrace(e.trace)},[t,e.trace]),t},w=(e={},r=!0)=>{const t=u.useMemo(()=>new T(e),[e]);return v(t,void 0,r),t},y="rotate:angle",j=({active:e,layers:r})=>{const t=u.useMemo(()=>({layers:r,translate:!0,stretch:!1,scale:!1,rotate:!0}),[r]),n=w(t,e);u.useEffect(()=>{const o="__rotating:angle__",s=n.on("rotatestart",i=>{i.features.forEach(c=>{const d=c.get(y)||0;c.set(o,d,!0)})}),a=n.on("rotateend",i=>{i.features.forEach(c=>{c.unset(o,!0)})}),l=n.on("rotating",i=>{i.features.forEach(c=>{const d=c.get(o);c.set(y,d-i.angle,!0)})});return()=>{f.unByKey(s),f.unByKey(a),f.unByKey(l)}},[n])};exports.RotateAnglePropertyName=y;exports.useDrawHoleInteraction=H;exports.usePopupOverlay=A;exports.useTooltipOverlay=B;exports.useTransformHandler=j;exports.useTransformInteraction=w;
//# sourceMappingURL=index.cjs.js.map
